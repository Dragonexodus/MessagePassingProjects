\input{Header}	
					
\title{Dokumentation zu den Projektaufgaben 1 und 2}
\subtitle{Message Passing Programmierung}

\author{Matthias Zober und Michael Horn}
\date{\today}
\begin{document}
\maketitle

\tableofcontents
\pagebreak

\section{Einleitung}
In dieser Dokumentation werden die Aufgaben \qq{Rechteckmustererkennung} sowie \qq{Numerische Integration mittels Parabelformel} betrachtet und hinsichtlich ihrer Parallelität untersucht.
Der entstandene Quellcode kann unter:\\
\url{https://github.com/MZober1993/MessagePassingProjects}\footnote{Letzter Aufruf: \today}
eingesehen werden.
\section{Projektaufgabe 1: Rechteckmustererkennung}
Das zu spezifizierende parallele Programm soll eine Rechteckmustererkennung über ein Cluster realisieren.
\subsection{Realisierung}
%Pseudocode? Verwendung (config), argumente,...
%Einschränkung (gerade Prozessoranzahl etc)
%Vll. Scatter und Gather nochmal erklären

Für die Umsetzung eines solchen Programms, ist es zunächst notwendig eine sequentielle Erkennung eines $n*m$ Digitalbild zu realisieren.
Die sequentielle Erkennung ist der Teil des Programms der sich nicht parallelisieren lässt. Für die Parallelisierung muss jeder Prozessor diese Erkennung auf sein Teilbild anwenden.

Im Wesentlichen wird ein Rechteck durch dass finden eines schwarzen Pixels \linebreak(schwarz=0, weiß=1) und das Überprüfen von ausschließenden Mustern. Die Erkennung kann einfach realisiert werden durch die Speicherung der Koordinaten des ersten (\texttt{startX} \& \texttt{startY}) und zuletzt gefundenen Pixels (\texttt{stopX} \& \texttt{stopY}) und die Länge der oberen gefunden Rechteckkante (\texttt{xSize}). Im folgenden erkennt man die ausschließenden Mustern mit deren Regeln.\newpage
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.75]{mismatches.png}
    \caption{Ausschließende Bit-Muster mit Regeln}
    \label{fig:mismatches}
\end{figure}

Werden diese Muster nicht erkannt, aber schwarze Pixel, dann existiert ein Rechteck (\texttt{FoundOne}). Andernfalls werden nicht zuzuordnende schwarze Pixel (\texttt{Mismatch}) oder gar keine schwarzen Pixel (\texttt{Nothing}) im Bild gefunden.

Nachdem jeder Prozess sein Teilbild bearbeitet hat muss ein ausgezeichneter Hauptprozess (\texttt{Master}) alle Ergebnisse zusammenfassen, dies geschieht in den folgenden Schritten.

\begin{enumerate}
	\item Gibt es ein Teilbild mit schwarzen Pixeln, welche aber kein Rechteck bilden, dann kann direkt abgebrochen werden mit: \texttt{Mismatch}.
	\item Wenn alle Teilbilder \texttt{Nothing} finden, dann kann auch abgebrochen werden mit \texttt{Nothing}.
	\item Gibt es nur ein \texttt{FoundOne} und sonst \texttt{Nothing}, kann das Rechteck ausgegeben werden.
\end{enumerate}

Falls mehrere \texttt{FoundOne} vorliegen und vorher nicht abgebrochen wurde muss der \texttt{Master} überprüfen ob die gefundenen Rechtecke zusammenhängend sind, dies kann durch folgende Kriterien überprüft werden.

\begin{enumerate}
	\item Die Start- \& Stop-X Werte stimmen bei jedem Rechteck überein.
	\item Bis auf dem ersten Prozess der ein Rechteck in einer Zeile gefunden hat, müssen alle schwarze Pixel in ihrer ersten Zeile finden.
	\item Bis auf dem letzten Prozess der ein Rechteck gefunden hat, müssen alle schwarzen Pixel in ihrer letzten Zeile finden.
\end{enumerate}

Nach dieser letzten Überprüfung kann der Master-Prozess das Ergebnis ermitteln und die Start- \& Stopp-Koordinaten des gefundenen Rechtecks ausgeben. 

Durch die Betrachtung der Umsetztung stellt man fest, dass für den Algorithmus ein Best-Case darin besteht sofort ein \texttt{Mismatch} zu finden, da direkt abgebrochen werden kann. Der Average-Case stellt ein Digitalbild ohne schwarze Pixel dar, da nach überprüfen aller Pixel abgebrochen werden kann, aber keine weiteren Überprufungen stattfinden. Der Worst-Case besteht darin mehrere Rechtecke zu finden, da alle Rechtecke zusammenhängend sein müssen. Für die Untersuchungen zur Laufzeit werden diese drei Fälle berücksichtigt.


\subsection{Verwendung}
\subsubsection{Ausführung}
Der Quellcode kann mit Hilfe des folgenden Aufrufs kompiliert werden:

\begin{itemize}
	\item \texttt{cmake CMakeLists.txt -DCMAKE\_BUILD\_TYPE=RELEASE \&\& make}
\end{itemize}

Mif folgenden Befehl wird das Programm auf 4 Prozessoren ausgeführt:

\begin{itemize}
	\item \texttt{mpirun -npernode 4 rectanglePatternDetection} \textbf{FILE}
\end{itemize}

Für das Programm können Kommandozeilenargumente zur Angabe des Konfigurationsfiles zur Erstellung des zu untersuchenden Digitalbildes angegeben werden.

\subsubsection{Konfigurationsfile}
Die Anwendung unterstützt drei Modi zur Erzeugung des Digitalbildes, welcher dieser Modi verwendet wird, steht immer in der ersten Zeile des Files.

\paragraph{Modus 2: Custom Mode}Der \texttt{Custom Mode} ermöglicht die direkte Angabe einer $n*n$ Matrix (ab Zeile zwei) aus Nullen und Einzen.

\paragraph{Modus 1: Single Fields \& Modus 0: Rectangle}
Um eine komfortable Eingabe zu realisieren, wird für die Modi 1 und 0 nicht die direkte Angabe der Matrix sondern nur die angabe einzelne Parameter realisiert, aus denen dann das Digitalbild im Programm generiert wird. Die zweite Zeile beschreibt die Größe $n$ und die Dritte die zu verwendende Hintergrundfarbe (0 oder 1). Aus diesen zwei Parametern kann im Programm leicht eine $n*n$ Matrix der angegebenen Hintergrundfarbe (0 oder 1) generiert werden. \\
Durch die vierte Zeile werden Koordinatenpaare in der Form: \texttt{x y} angegeben. Modus 1 interpretiert diese Koordinaten als einzelne Felder, welche im Bild umgedreht werden müssen. Modus 0 hingegen interpretiert nur die ersten drei Koordinatenpaare als die Ortsvektoren der oberen Rechteck-Ecke, die das Rechteck aufspannt. Es ist notwendig, dass dabei die Reihenfolge: obere Ecke links, obere Ecke rechts und untere Ecke links eingehalten wird.

Durch die angegebenen Kodierungen (Modus 1 und 0) ist es möglich sehr große Digitalbilder mit der Anwendung zu testen, ohne das diese tatsächlich  als physisch gespeichterte Dateien existieren müssen. Im Gegensatz dazu kann durch Modus 2 direkt die Matrix eingegeben werden, dieser Modus findet vorallem für kleinere $n$ Anwendung. Durch das Konfigurationsfile können somit sehr leicht Digitalbilder mit den vorher betrachteten Fällen \texttt{Nothing}, \texttt{Mitmatch} und \texttt{FoundOne} für kleine und große $n$ erzeugt werden.
%Speed-Up , Effizienz
%Wo liegt das Maximum für das zu untersuchende quadratische Raster?
%Kommunikationsoverhead
\subsection{Laufzeitverhalten}
% Auswertungsoverhead durch Master (Auswertung von Gather - parallel)
Wie man aus dem gegebenen Laufzeitmessungen entnehmen kann, liefert der Best-Case \texttt{Mismatch} wesentlich kürzere Laufzeiten für den sequentiellen Fall, als für den parallelen. Dies ist damit begründet, dass kein Kommunikationsoverhead für die Auswertung existiert, da der \texttt{Master} direkt seine Suche abbrechen kann, während im parallele Programm der \texttt{Master} auf alle Teilergebnisse warten muss.

\subsubsection{Festes n}
\begin{tikzpicture}
\begin{axis}
[            axis x line=middle,
            axis y line=middle,
            enlarge y limits=true,
            width=15cm, height=8cm,     % size of the image
            grid = major,
            grid style={dashed, gray!30},
            ylabel=Time in s,
            xlabel=n,
            legend style={at={(0.1,-0.1)}, anchor=north}
]
\addplot[black, mark=x] table [x=n, y=T2 , col sep=space] {../rectangle/measures/nScaling/88/measure0.csv};
\addplot[blue, mark=*] table [x=n, y=T2 , col sep=space] {../rectangle/measures/nScaling/88/measure1.csv};
\addplot[red, mark=+] table [x=n, y=T2 , col sep=space] {../rectangle/measures/nScaling/88/measure2.csv};
\legend{0,1,2}
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}
[            axis x line=middle,
            axis y line=middle,
            enlarge y limits=true,
            width=15cm, height=8cm,     % size of the image
            grid = major,
            grid style={dashed, gray!30},
            ylabel=Time in s,
            xlabel=n,
            legend style={at={(0.1,-0.1)}, anchor=north}
]
\addplot[black, mark=x] table [x=n, y=T2 , col sep=space] {../rectangle/measures/nScaling/44/measure0.csv};
\addplot[blue, mark=*] table [x=n, y=T2 , col sep=space] {../rectangle/measures/nScaling/44/measure1.csv};
\addplot[red, mark=+] table [x=n, y=T2 , col sep=space] {../rectangle/measures/nScaling/44/measure2.csv};
\legend{0,1,2}
\end{axis}
\end{tikzpicture}
\subsubsection{Festes p}
\begin{tikzpicture}
\begin{axis}
[            axis x line=middle,
            axis y line=middle,
            enlarge y limits=true,
            width=15cm, height=8cm,     % size of the image
            grid = major,
            grid style={dashed, gray!30},
            ylabel=Time in s,
            xlabel=hosts,
            legend style={at={(0.1,-0.1)}, anchor=north}
]
\addplot[black, mark=x] table [x=hosts, y=T1 , col sep=space] {../rectangle/measures/processorScaling/44/40000/measure0.csv};
\addplot[blue, mark=*] table [x=hosts, y=T1 , col sep=space] {../rectangle/measures/processorScaling/44/40000/measure1.csv};
\addplot[red, mark=+] table [x=hosts, y=T1 , col sep=space] {../rectangle/measures/processorScaling/44/40000/measure2.csv};
\legend{0,1,2}
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}
[           axis x line=middle,
            axis y line=middle,
            enlarge y limits=true,
            width=15cm, height=8cm,     % size of the image
            grid = major,
            grid style={dashed, gray!30},
            ylabel=Time in s,
            xlabel=hosts,
            legend style={at={(0.1,-0.1)}, anchor=north}
]
\addplot[black, mark=x] table [x=hosts, y=T2 , col sep=space] {../rectangle/measures/processorScaling/88/40000/measure0.csv};
\addplot[blue, mark=*] table [x=hosts, y=T2 , col sep=space] {../rectangle/measures/processorScaling/88/40000/measure1.csv};
\addplot[red, mark=+] table [x=hosts, y=T2 , col sep=space] {../rectangle/measures/processorScaling/88/40000/measure2.csv};
\legend{0,1,2}
\end{axis}
\end{tikzpicture}
\subsection{Fazit}

\pagebreak

\section{Projektaufgabe 2: Numerische Integration mittels Parabelformel}
\lstset{language=Fortran,frame=none, keepspaces=false,tabsize=1,captionpos=b, basicstyle=\scriptsize,showstringspaces=false,breaklines=true}  
In diesem Abschnitt wird auf die Projektaufgabe 2 eingegangen.
Zunächst wird kurz erklärt wie das Programm kompiliert und gestartet wird sowie auf die Kommandozeilenargumente eingegangen.
Im Anschluss wird die Realisierung und damit die Lösung des Problems betrachtet.
Anschließend erfolgt die Auswertung und im letzten Abschnitt wird ein Fazit gezogen.

\subsection{Verwendung}
\label{ref:verwendung}
Der Quellcode kann mit dem Aufruf von 1 auf dem MC-3-System kompiliert und mit 2 ausgeführt werden:
\begin{itemize}
	\item[1.] f77.px -o A2star.px A2star.f
	\item[2.] run -f0 4 2 A2star.px \textbf{FUNCTION} \textbf{N}
\end{itemize}
Für das Programm können Kommandozeilenargumente zur Auswahl der Testfunktion und die Größe der zu berechnenden Teilstücke des Integrals angegeben werden.
\paragraph{FUNCTION:}
Das Programmargument \textbf{FUNCTION} entscheidet darüber, welche der beiden gegebenen Testfunktionen verwendet wird.
Als gültige Eingabe wird 1 für Funktion 1 und 2 für Funktion 2 erwartet.
\paragraph{N:}
Das zweite Programmargument \textbf{N} gibt die 2er Potenz der zu berechnenden Teilstücke des Integrals an.
Je größer das \textbf{N}, umso genauer wird das berechnete PI.
De höchstmöglichste zulässige Eingabe ist 20, das sind 1048576 zu berechnende Teilstücke.
Diese Vorgehensweise soll zum Einen sicher stellen, dass \textbf{N} stets durch 2 Teilbar ist und zum Anderen das Laufzeitmessen vereinfachen, da ein exponentielles Wachstum vorliegt.
Sollte kein Programmargument angeben werden, so wird intern die Funktion 1 mit $n = 2^{15} = 32768$ verwendet.

Weiterhin muss die Divison von n durch Prozessorzahl ganzahlig sein, damit stets gewährleistet ist, dass die zu berechnende Anzahl an Teilstücke pro Prozessor eine ganzzahlige ist.

\subsection{Realisierung}
\label{ref:realisierung}
Grundlegend wurde sich bei der Realisierung für eine Stern-Topologie entschieden.
Gewählt wurde diese Topologie, da bei der Parallelisierung dieser Aufgabe ein Master existert, welche alle Teilergebnisse empfängt und summiert.
Weiterhin wurde diese Topologie bereits in einem Seminar implementiert.

Bedingt durch die Realisierung als Kommandozeilenparameter, entfällt der Kommunikationsoverhead für das Verteilen von \textbf{N} und \textbf{FUNCTION}.
Daher kennen alle Prozessoren \textbf{N} sowie die Testfunktion beim Programmstart.

Die Prozessoren können explizit ihre eigenen Bereich für die Teilstücke bestimmen und somit die numerische Berechnung durchführen.
Nach Abschluss der Berechnungen, werden diese an den Master-Prozessor gesendet.
Der Master-Prozessor summiert die Ergebnisse der anderen Prozessoren zu seinem eigenem Ergebnis auf und wendet die Multiplikation h/3 auf das Ergebnis an.
Im Anschluss werden die Ergebnisse wie Referenzwert-PI, Berechnetes-PI, Abweichung und Laufzeit (nicht in Abbildung dargestellt) ausgegeben. 
Die \autoref{ref:main} zeigt dies.
\begin{figure}[h]
\hrulefill

\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
	call startIntegration(f,n,integral,h)
	if(id.eq.0) then
		summe = integral
		do i=1,(np-1)
			call recv(topid,links(i),integral,8)
			summe = summe + h/3 * integral
		enddo
	else
		call send(topid, link,integral,8)
	endif
\end{lstlisting}
	\caption{Empfangen und Auswerten}
	\label{ref:main}
\end{minipage}
\hfill
\vline
\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
	nL = n / nprocs()
	aL = a + id * nL * h
	bL = aL + nL * h
	summe = getVal(f,aL) + getVal(f,bL)   
	step = aL + h
	do i=1,nL-1
		factor=2**(mod(i,2) + 1)
		summe = summe + (dble(getVal(f,step) * factor)
		step = step + h    
	enddo
\end{lstlisting}
	\caption{Berechnung der Teilstück}
	\label{ref:intervall}
\end{minipage}

\hrulefill
\end{figure}

Die numerische Berechnung des Integrals wird durch jeden Prozessor ausgeführt, aber jeder Prozessor führt nur einen Teil der kompletten Berechnung aus.
Die eigentliche Berechnung ist in der \autoref{ref:intervall} zu sehen.
Zunächst berechnet jeder Prozessor die Anzahl der durchzuführenden Berechnungen, als lokales \textbf{n} (\textbf{nL}).
Im Anschluss werden Startpunkt (\textbf{aL}) und Endpunkt (\textbf{bL}) ermittelt.
Die Funktionswerte von \textbf{aL} und \textbf{bL} der Testfunktion werden addiert und in einer Summe gespeichert.
Im Anschluss werden die Zwischenstücke mit entsprechendem Faktor berechnet und ebenfalls summiert.
Die Variable \textbf{h} gibt dabei die allgemeine Schrittweite an und \textbf{step} den derzeitigen Schrittwert.

Nach erfolgter Berechnung sendet jeder Prozessor sein Ergebnis an den Master (falls der Prozessor nicht selbst der Master ist)

\subsection{Ergebnisse}
\label{ref:ergebnisse}

\subsubsection{Testfunktionen}

Für die Testfunktionen wird der Referenzwert \textbf{3.141592653589793} verwendet.
Die \autoref{ref:piP} zeigt die Abweichung zum Referenzwert von Pi bei einer konstanten Prozessoranzahl von 8 und einem sich verändernden \textbf{n}.
Die \autoref{ref:piN} zeigt ebenfalls die Abweichung, aber hier wird ein konstantes \textbf{n} von 32768 verwendet und die Prozessoranzahl variiert.

Wie in den Tabellen zu sehen ist liefert die Testfunktion 2 schneller bessere Pi-Näherungswerte als Funktion 1.
Ein Grund dafür, dass die Funktion 1 schlechte Näherungswerte liefert, liegt unter Anderem an der Oberegrenze.
Diese Obergrenze ist Pi selbst.
Zusätzlich sind in der Funktion 1 die Schrittweiten bedeutend größer, als bei der Funktion 2, daher benötigt die Funktion ein größeres \textbf{n} um mehr Teilstücke berechnen zu können und somit ein genaueres Ergebnis zu liefern.

\begin{center}
\begin{figure}[h]
\begin{minipage}{0.45\textwidth}
	\pgfplotstabletypeset[col sep=space
	,every head row/.style={before row={\hline},after row=\hline}
	,every last row/.style={after row=\hline}
	,every even column/.style={column type/.add={|}{|}}
	,columns={n,Abweichung-F1,Abweichung-F2}
	]{../integration/functionDiffp8.csv}
	\caption{Mit 8 Prozessoren}
	\label{ref:piP}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
	\pgfplotstabletypeset[col sep=space
	,every head row/.style={before row={\hline},after row=\hline}
	,every last row/.style={after row=\hline}
	,every even column/.style={column type/.add={|}{|}}
	,columns={p,Abweichung-F1,Abweichung-F2}
	]{../integration/functionDiffn.csv}
	\caption{Mit n = 32768}
	\label{ref:piN}
\end{minipage}
\end{figure}
\end{center}


%Speed-Up , Effizienz
\subsubsection{Laufzeitverhalten}
\paragraph{SpeedUp und Effizienz}


\begin{figure}[h]
\begin{minipage}{0.45\textwidth}
\begin{tikzpicture}
\begin{axis}
[ 
           	grid = major,
			scale = 1,
            grid style={dashed, gray!30},
            ylabel=SpeedUp,
            xlabel=p,
            legend style={at={(0.1,-0.1)}, anchor=north}
]
\addplot[red, mark=*] table [x=p, y=SpeedUp15 , col sep=space]{../integration/speedUpF1.csv};
\addplot[blue, mark=+] table [x=p, y=SpeedUp12 , col sep=space]{../integration/speedUpF1.csv};
\addplot[black] table [x=p, y=IdealSpeedUp, col sep=space]{../integration/speedUpF1.csv};
\legend{n = 32768,n = 4096, Ideal}
\end{axis}
\end{tikzpicture}
	\caption{SpeedUp Funktion 1}
	\label{ref:speedF1}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\begin{tikzpicture}
\begin{axis}
[  			grid = major,
			scale = 1,
            grid style={dashed, gray!30},
            ylabel=SpeedUp,
            xlabel=p,
            legend style={at={(0.1,-0.1)}, anchor=north}
]
\addplot[red, mark=*] table [x=p, y=SpeedUp15 , col sep=space]{../integration/speedUpF2.csv};
\addplot[blue, mark=*] table [x=p, y=SpeedUp12 , col sep=space]{../integration/speedUpF2.csv};
\addplot[black] table [x=p, y=IdealSpeedUp, col sep=space]{../integration/speedUpF2.csv};
\legend{n = 32768,n = 4096,Ideal}
\end{axis}
\end{tikzpicture}
	\caption{SpeedUp Funktion 2}
	\label{ref:speedF2}
\end{minipage}
\end{figure}

\begin{figure}[h]
\begin{minipage}{0.45\textwidth}
\begin{tikzpicture}
\begin{axis}
[   
            grid = major,
            grid style={dashed, gray!30},
            ylabel=Effizienz,
            xlabel=p,
            legend style={at={(0.1,-0.1)}, anchor=north}
]
\addplot[red, mark=*] table [x=p, y=Effizienz15 , col sep=space]{../integration/speedUpF1.csv};
\addplot[blue, mark=x] table [x=p, y=Effizienz12 , col sep=space]{../integration/speedUpF1.csv};
\addplot[black] table [x=p, y=IdealEffizienz, col sep=space]{../integration/speedUpF1.csv};
\legend{n = 32768,n = 4096}
\end{axis}
\end{tikzpicture}
	\caption{Effizienz Funktion 1}
	\label{ref:EffizienzF1}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\begin{tikzpicture}
\begin{axis}
[   
            grid = major,
            grid style={dashed, gray!30},
            ylabel=Effizienz,
            xlabel=p,
            legend style={at={(0.1,-0.1)}, anchor=north}
]
\addplot[red, mark=*] table [x=p, y=Effizienz15 , col sep=space]{../integration/speedUpF2.csv};
\addplot[blue, mark=x] table [x=p, y=Effizienz12 , col sep=space]{../integration/speedUpF2.csv};
\addplot[black] table [x=p, y=IdealEffizienz, col sep=space]{../integration/speedUpF2.csv};
\legend{n = 32768,n = 4096}
\end{axis}
\end{tikzpicture}
	\caption{Effizienz Funktion 2}
	\label{ref:EffizienzF2}
\end{minipage}
\end{figure}

\subsection{Fazit}
\label{ref:fazit}
Kommunikationsoverhead spielt hier eine untergeordnete Rolle, da Minimum an Kommunikation zur Berechnung notwendig ist.
%TODO
Weiterhin lohnt sich die Parallelisierung,..


%\appendix
%\section{Quellcode Aufgabe 1}
%
%\section{Quellcode Aufgabe 2}
%\lstset{language=Fortran,numbers=left, keepspaces=false, basicstyle=\footnotesize,showstringspaces=false} 
%\lstinputlisting[]{../integration/A2star.f}

\end{document}
