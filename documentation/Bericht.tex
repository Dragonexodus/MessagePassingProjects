\input{Header}	
					
\title{Dokumentation zu den Projektaufgaben 1 und 2}
\subtitle{Message Passing Programmierung}

\author{Matthias Zober und Michael Horn}
\date{\today}
\begin{document}
\maketitle

\tableofcontents
\pagebreak

\section{Einleitung}
In dieser Dokumentation werden die Aufgaben \qq{Rechteckmustererkennung} sowie \qq{Numerische Integration mittels Parabelformel} betrachtet und hinsichtlich ihrer Parallelität untersucht.
Der entstandene Quellcode kann unter:\\
\url{https://github.com/MZober1993/MessagePassingProjects}\footnote{Letzter Aufruf: \today}
eingesehen werden.
\section{Projektaufgabe 1: Rechteckmustererkennung}
Das zu spezifizierende parallele Programm soll eine Rechteckmustererkennung über ein Cluster realisieren.
\subsection{Realisierung}
%Pseudocode? Verwendung (config), argumente,...
%Einschränkung (gerade Prozessoranzahl etc)
%Vll. Scatter und Gather nochmal erklären

Für die Umsetzung eines solchen Programms, ist es zunächst notwendig eine sequentielle Erkennung eines $n*m$ Digitalbild zu realisieren.
Die sequentielle Erkennung ist der Teil des Programms der sich nicht parallelisieren lässt. Für die Parallelisierung muss jeder Prozessor diese Erkennung auf sein Teilbild anwenden.

Im wesentlichen wird ein Rechteck durch dass finden eines schwarzen Pixels und das Überprüfen von ausschließenden Mustern. Die Erkennung kann einfach realisiert werden durch die Speicherung der Koordinaten des ersten und zuletzt gefundenen Pixels, die Länge der oberen gefunden Rechteckkante und die Information ob eine Zeile mit schwarze Pixeln von weißen Zeilen umschlossen wurde. Im folgenden erkennt man die ausschließenden Mustern mit deren Regeln.
\includegraphics[scale=0.8]{mismatches.png}

Werden diese Muster nicht erkannt, aber schwarze Pixel erkannt, dann existiert ein Rechteck (\texttt{FoundOne}). Andernfalls werden nicht zuzuordnende schwarze Pixel (\texttt{Mismatch}) oder gar keine schwarzen Pixel (\texttt{Nothing}) im Bild gefunden.

Nachdem jeder Prozess sein Teilbild bearbeitet hat muss ein ausgezeichneter Hauptprozess (\texttt{Master}) alle Ergebnisse zusammenfassen, dies geschieht in folgenden Schritten.

\begin{enumerate}
	\item Gibt es ein Teilbild mit schwarzen Pixeln, welche aber kein Rechteck bilden, dann kann direkt abgebrochen werden mit: \texttt{Mismatch}.
	\item Wenn alle Teilbilder \texttt{Nothing} finden, dann kann auch abgebrochen werden mit \texttt{Nothing}.
	\item Gibt es nur ein \texttt{FoundOne} und sonst \texttt{Nothing}, kann das Rechteck ausgegeben werden.
\end{enumerate}

Falls mehrere \texttt{FoundOne} vorliegen und vorher nicht abgebrochen wurde muss der \texttt{Master} überprüfen ob die gefundenen Rechtecke zusammenhängend sind, dies kann durch folgende Kriterien überprüft werden.

\begin{enumerate}
	\item Die Start- \& Stop-X Werte stimmen bei jedem Rechteck überein.
	\item Bis auf dem ersten Prozess der ein Rechteck in einer Zeile gefunden hat, müssen alle schwarze Pixel in ihrer ersten Zeile finden.
	\item Bis auf dem letzten Prozess der ein Rechteck gefunden hat, müssen alle schwarzen Pixel in ihrer letzten Zeile finden.
\end{enumerate}

Nach dieser letzten Überprüfung kann der Master-Prozess das Ergebnis ermitteln und die Start- \& Stopp-Koordinaten des gefundenen Rechtecks ausgeben. 

Durch die Betrachtung der Umsetztung stellt man fest, dass für den Algorithmus ein Best-Case darin besteht sofort ein \texttt{Mismatch} zu finden, da direkt abgebrochen werden kann. Der Average-Case stellt ein Digitalbild ohne schwarze Pixel dar, da nach überprüfen aller Pixel abgebrochen werden kann, aber keine weiteren Überprufungen stattfinden. Der Worst-Case besteht darin mehrere Rechtecke zu finden, da alle Rechtecke zusammenhängend sein müssen. Für die Untersuchungen zur Laufzeit werden, stets diese drei Fälle berücksichtigt.


\subsection{Verwendung}
\subsubsection{Ausführung}
Der Quellcode kann mit Hilfe des folgenden Aufrufs auf dem PC oder dem Cluster kompiliert werden:

\begin{itemize}
	\item \texttt{cmake CMakeLists.txt -DCMAKE\_BUILD\_TYPE=RELEASE \&\& make}
\end{itemize}

Mif folgenden Befehl wird das Programm auf 4 Prozessoren ausgeführt:

\begin{itemize}
	\item \texttt{mpirun -npernode 4 rectanglePatternDetection} \textbf{FILE}
\end{itemize}

Für das Programm können Kommandozeilenargumente zur Angabe des Konfigurationsfiles zur Erstellung des zu untersuchenden Digitalbildes angegeben werden.

\subsubsection{Konfigurationsfile}
Die Anwendung unterstützt drei Modi zur Erzeugung des Digitalbildes, welcher dieser Modi verwendet wird, steht immer in der ersten Zeile des Files.

\paragraph{Modi 2 - Custom Mode}Der \texttt{Custom Mode} ermöglicht die direkte angabe einer n*n Matrix aus Nullen und Einzen.

TODO: Beschreibe dass Modi 0 und 1 die Eingabe mit der Angabe von n und der Hintergrundfarbe gemeinsam verwenden 

TODO: beschreibe die Erzeugung von Rechtecken mittels Mode 0 und die Erzeugung von einzelnen Punkten durch Mode 1

%Speed-Up , Effizienz
%Wo liegt das Maximum für das zu untersuchende quadratische Raster?
%Kommunikationsoverhead
\subsection{Laufzeitverhalten}
% Auswertungsoverhead durch Master (Auswertung von Gather - parallel)

\subsubsection{Festes n}
\begin{tikzpicture}
\begin{axis}
[            axis x line=middle,
            axis y line=middle,
            enlarge y limits=true,
            width=15cm, height=8cm,     % size of the image
            grid = major,
            grid style={dashed, gray!30},
            ylabel=Time in s,
            xlabel=n,
            legend style={at={(0.1,-0.1)}, anchor=north}
]
\addplot[black, mark=x] table [x=n, y=T2 , col sep=space] {../rectangle/measures/nScaling/88/measure0.csv};
\addplot[blue, mark=*] table [x=n, y=T2 , col sep=space] {../rectangle/measures/nScaling/88/measure1.csv};
\addplot[red, mark=+] table [x=n, y=T2 , col sep=space] {../rectangle/measures/nScaling/88/measure2.csv};
\legend{0,1,2}
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}
[            axis x line=middle,
            axis y line=middle,
            enlarge y limits=true,
            width=15cm, height=8cm,     % size of the image
            grid = major,
            grid style={dashed, gray!30},
            ylabel=Time in s,
            xlabel=n,
            legend style={at={(0.1,-0.1)}, anchor=north}
]
\addplot[black, mark=x] table [x=n, y=T2 , col sep=space] {../rectangle/measures/nScaling/44/measure0.csv};
\addplot[blue, mark=*] table [x=n, y=T2 , col sep=space] {../rectangle/measures/nScaling/44/measure1.csv};
\addplot[red, mark=+] table [x=n, y=T2 , col sep=space] {../rectangle/measures/nScaling/44/measure2.csv};
\legend{0,1,2}
\end{axis}
\end{tikzpicture}
\subsubsection{Festes p}
\begin{tikzpicture}
\begin{axis}
[            axis x line=middle,
            axis y line=middle,
            enlarge y limits=true,
            width=15cm, height=8cm,     % size of the image
            grid = major,
            grid style={dashed, gray!30},
            ylabel=Time in s,
            xlabel=hosts,
            legend style={at={(0.1,-0.1)}, anchor=north}
]
\addplot[black, mark=x] table [x=hosts, y=T1 , col sep=space] {../rectangle/measures/processorScaling/44/40000/measure0.csv};
\addplot[blue, mark=*] table [x=hosts, y=T1 , col sep=space] {../rectangle/measures/processorScaling/44/40000/measure1.csv};
\addplot[red, mark=+] table [x=hosts, y=T1 , col sep=space] {../rectangle/measures/processorScaling/44/40000/measure2.csv};
\legend{0,1,2}
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}
[            axis x line=middle,
            axis y line=middle,
            enlarge y limits=true,
            width=15cm, height=8cm,     % size of the image
            grid = major,
            grid style={dashed, gray!30},
            ylabel=Time in s,
            xlabel=hosts,
            legend style={at={(0.1,-0.1)}, anchor=north}
]
\addplot[black, mark=x] table [x=hosts, y=T2 , col sep=space] {../rectangle/measures/processorScaling/88/40000/measure0.csv};
\addplot[blue, mark=*] table [x=hosts, y=T2 , col sep=space] {../rectangle/measures/processorScaling/88/40000/measure1.csv};
\addplot[red, mark=+] table [x=hosts, y=T2 , col sep=space] {../rectangle/measures/processorScaling/88/40000/measure2.csv};
\legend{0,1,2}
\end{axis}
\end{tikzpicture}
\subsection{Fazit}

\pagebreak

\section{Projektaufgabe 2: Numerische Integration mittels Parabelformel}
\lstset{language=Fortran,frame=none, keepspaces=false, basicstyle=\footnotesize,showstringspaces=false}  
In diesem Abschnitt wird auf die Projektaufgabe 2 eingegangen.
Zunächst wird im \autoref{ref:verwendung} kurz erklärt wie das Programm kompiliert und gestartet wird sowie auf die Kommandozeilenargumente eingegangen.
Im Anschluss wird die Realisierung und damit die Lösung des Problems im \autoref{ref:realisierung} betrachtet.
Anschließend erfolgt im \autoref{ref:ergebnisse} die Auswertung der Realisierung.
Im letzten \autoref{ref:fazit} wird ein Fazit zu der Aufgabe gezogen.

\subsection{Verwendung}
\label{ref:verwendung}
Der Quellcode kann mit Hilfe folgendes Aufrufes auf dem MC-3-System kompiliert werden:
\begin{itemize}
	\item f77.px -o A2star.px A2star.f
\end{itemize}
Mit folgendem Befehl wird das Programm ausgeführt:
\begin{itemize}
	\item run -f0 4 2 A2star.px \textbf{funktion} \textbf{n}
\end{itemize}

Für das Programm können Kommandozeilenargumente zur Auswahl der Testfunktion und die Größe der zu berechnenden Teilstücke des Integrals angegeben werden.
\paragraph{funktion:}
Das Programmargument \textbf{funktion} entscheidet darüber, welche der beiden gegebenen Testfunktionen verwendet wird.
Als gültige Eingabe wird 1 für Funktion 1 und 2 für Funktion 2 erwartet.
\paragraph{n:}
Das zweite Programmargument \textbf{n} gibt die 2er Potenz der zu berechnenden Teilstücke des Integrals an.
Je größer das \textbf{n}, umso genauer wird das berechnete PI.
De höchstmöglichste zulässige Eingabe ist 20, das sind 1048576 zu berechnende Teilstücke.
Diese Vorgehensweise soll zum Einen sicher stellen, dass \textbf{n} stets durch 2 Teilbar ist und zum Anderen das Laufzeitmessen vereinfachen, da ein exponentielles Wachstum vorliegt.
Sollte kein Programmargument angeben werden, so wird intern die Funktion 1 mit $n = 2^{15} = 32768$ verwendet.

Weiterhin wird eine ungerade Prozessorzahl ausgeschlossen, damit stets gewährleistet ist, dass die zu berechnende Anzahl an Teilstücke pro Prozessor eine ganzzahlige Zahl ist.

\subsection{Realisierung}
\label{ref:realisierung}
Grundlegend wurde sich bei der Realisierung für eine Stern-Topologie entschieden.
Gewählt wurde diese Topologie, da bei der Parallelisierung dieser Aufgabe ein Master existert, welche alle Teilergebnisse empfängt und summiert.
Weiterhin wurde diese Topologie bereits in einem Seminar implementiert.
Wie die Topologie erstellt wird zeigt \autoref{ref:top}.

\begin{lstlisting}[caption=Erzeugen der Stern-Topologie\label{ref:top}]
	if(id.eq.0) then
		do i=1,(np-1)
			links(i)=addnewlink(topid,i,1)
		enddo
	else
		link=addnewlink(topid,0,1)
	endif
\end{lstlisting}

Bedingt durch die Realisierung als Kommandozeilenparameter, entfällt der Kommunikationsoverhead für das Verteilen von \textbf{n} und \textbf{funktion}.
Daher kennen alle Prozessoren \textbf{n} sowie die Testfunktion beim Programmstart.

Die Prozessoren können explizit ihre eigenen Bereich für die Teilstücke bestimmen und somit die numerische Berechnung durchführen.
Nach Abschluss der Berechnungen, werden diese an den Master-Prozessor gesendet.
Der Master-Prozessor summiert die Ergebnisse der anderen Prozessoren zu seinem eigenem Ergebnis auf und wendet die Multiplikation h/3 auf das Gesamtergebnis an.
Im Anschluss werden die Ergebnisse wie Referenzwert-PI, Berechnetes-PI, Abweichung und Laufzeit (nicht im Listng dargestellt) ausgegeben. 
Das folgende \autoref{ref:main} zeigt dies.

\begin{lstlisting}[caption=Empfangen und Auswerten\label{ref:main}]
c	starte die Integration
	call startIntegration(f,n,integral,h)
	if(id.eq.0) then
		print*,"use f:",f," with n:",n
c  	Integralteilstück vom Master
		summe = integral
		do i=1,(np-1)
c 	Empfange alle Teilstücke und addiere Sie
			call recv(topid,links(i),integral,8)
			summe = summe + integral
		enddo
		summe = h/3 *summe
		derivation =  PI() - summe
		print*,"--------------------------"
		print*,"PI Referece:",PI()                   
		print*,"PI Integral:",summe
		print*,"PI Derivat.:",derivation
	else
c	Sende Integralteilstücke zum Master
		call send(topid, link,integral,8)
	endif
\end{lstlisting}

Die numerische Berechnung des Integrals wird durch jeden Prozessor ausgeführt, aber jeder Prozessor führt nur einen Teil der kompletten Berechnung aus.
Die eigentliche Berechnung ist in dem \autoref{ref:intervall} zu sehen.
Zunächst berechnet jeder Prozessor die Anzahl der durchzuführenden Berechnungen, als lokales \textbf{n} (\textbf{nL}).
Im Anschluss werden Startpunkt (\textbf{aL}) und Endpunkt (\textbf{bL}) ermittelt.
Die Funktionswerte von \textbf{aL} und \textbf{bL} der Testfunktion werden addiert und in einer Summe gespeichert.
Im Anschluss werden die Zwischenstücke mit entsprechendem Faktor berechnet und ebenfalls summiert.
Die Variable \textbf{h} gibt dabei die allgemeine Schrittweite an und \textbf{step} die derzeitigen Schrittwert.

Nach erfolgter Berechnung sendet jeder Prozessor sein Ergebnis an den Master (falls der Prozessor nicht selbst der Master ist)

\begin{lstlisting}[caption=Berechnen der relevanten Bereiche für jeden Prozessor\label{ref:intervall}]
	id = myprocid() 
	nL = n / nprocs()
	aL = a + id * nL * h
	bL = aL + nL * h
c	Randwerte, getVal liefert Funktionswert der Testfunktion
	summe = getVal(f,aL) + getVal(f,bL)   
	step = aL + h
c 	Berechnung zwischenstücke, factor alterniert mit 2 und 4
	do i=1,nL-1
		exponent = mod(i,2) + 1
		factor=2**exponent
		summe = summe + dble(getVal(f,step) * factor)
		step = step + h    
	enddo
\end{lstlisting}

\subsection{Ergebnisse}
\label{ref:ergebnisse}
%TODO Tabellen

\subsubsection{Testfunktionen}

Wie in den Tabellen zu sehen ist liefert die Testfunktion 2 schneller bessere PI-Werte als Funktion 1.
Ein Grund dafür das Testfunktion 1 schlechtere Ergebnisse als Funktion 2 liefert, könnte damit zusammenhängen, dass für die Funktion 1 die Oberegrenze PI selbst ist.
%TODO Unterschiede Genauigkeit der Funktionen mit Begründung

%Speed-Up , Effizienz
\subsubsection{Laufzeitverhalten}
\paragraph{Festes n}
\paragraph{Festes p}

\subsection{Fazit}
\label{ref:fazit}
Kommunikationsoverhead spielt hier eine untergeordnete Rolle, da Minimum an Kommunikation zur Berechnung notwendig ist.
%TODO
Weiterhin lohnt sich die Parallelisierung,..


%\appendix
%\section{Quellcode Aufgabe 1}
%
%\section{Quellcode Aufgabe 2}
%\lstset{language=Fortran,numbers=left, keepspaces=false, basicstyle=\footnotesize,showstringspaces=false} 
%\lstinputlisting[]{../integration/A2star.f}

\end{document}
